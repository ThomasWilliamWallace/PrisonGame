Aim:
	Run htn_planner code in Unreal Engine.
	Run htn_planner code in unit tests.
	Optional: htn_planner code is usable outside of Unreal Engine.

Inheritance:
Pros:
	n/a
Cons:
	Cannot mix virtual functions with Unreal Engine objects, due to RTTI incompatibility.
	(Unreal uses it's own implementation of virtual table methods, and an object cannot inherit from an Unreal Object and a non-unreal object.)
	This rules out Unreal inheriting from htn_planner base classes.

Composition:
Pros:
	Htn_planner classes can be included in Unreal objects via composition.
Cons:
	All Unreal code must go:
		item->item_data->item_type
	Instead of:
		item->item_type
	It will also prevent blueprint access of this data.

Adaptor classes:
Pros:
	Htn_planner and Unreal can access data members simply, like:
		item->get_item_type()
Cons:
	Requires large amounts of adaptor boilerplate to be written, defining getter functions for all planner-relevant data.
	
Have all htn_planner code interface with the outside world of Unreal / textworld via a createHTNWorldState function (and a similar output format):
Pros:
	htn_planner is totally isolated from Unreal Engine.
	All Unreal code dealing with htn_planner is isolated to one place
Cons:
	Have to maintain separate code for htn_planner objects and external Unreal / textworld objects.
		Can mitigate this somewhat by importing htn_planner code into textworld.
		
Conclusion:
	Have all htn_planner code interface with the outside world through the createHTNWorldState function.
	Most of the programming problems I'm having are due to trying to share code between two languages- standard C++, and Unreal Engine C++.
	Instead, maintain a clear boundary between the two codebases.
	It's inevitable that we will need to have code to explicitly convert between the Unreal objects and the htn_planner objects.
	


Htn_planner should contain:
	HTNPlanner.h
	abstract class for HTNWorldState
	abstract class / entrypoint for translateToHTNWorldState
	means for output:
		planner outputs a list of shared_ptrs to HTNPrimitives
		An HTNPrimitive has got 'preconditions' and 'effect on HTNWorldState'.
			these both deal only with HTNWorldState.
		An HTNPrimitive also has an 'Operate' function.
			This is meant to trigger the real-world effect of the HTNPrimitive.
			This code will differ between Unreal and textworld, preventing code sharing.
			Two ways to deal with this:
				1: output a command, which is then interpreted by further, simulation-specific code.
					This is the current approach, outputting a 'BaseAction'.
				2: 'Operate' contains the actual code.
					This removes a layer of indirection.
					But we need to populate 'Operate' differently in Unreal and in textworld.
					We can define 'Operate' in Unreal,
						and then include it into textworld,
							where we override 'Operate'.
						
Unreal should contain:
	All game code by default.
	Because it's easier for textworld to include code from Unreal,
		and then ignore the unreal-specific macro, than vice versa.
	implementation class for HTNWorldState
	implementation class for translateToHTNWorldState
	
Textworld will:
	Include any shared code from Unreal, and then ignore Unreal-specific macros.
	Textworld will override anything that needs changed- this is easier than in Unreal.
	Textworld overriding or adapting things is also good from a performance standpoint.
		As textworld can handle a layer of function indirection, but we prefer to keep the fastest speeds for Unreal.
	implementation class for translateToHTNWorldState
